// Copyright (c) The cargo-guppy Contributors
// SPDX-License-Identifier: MIT OR Apache-2.0

//! Generate build summaries from `CargoSet` instances.
//!
//! Currently available through the `summaries` feature, and hidden because it is not part of the
//! stable `guppy` API.

use crate::graph::cargo::{CargoOptions, CargoResolverVersion, CargoSet};
use crate::graph::feature::FeatureSet;
use crate::graph::{DependencyDirection, PackageGraph, PackageMetadata, PackageSource};
pub use guppy_summaries::*;
use serde::{Deserialize, Serialize};
use std::collections::BTreeSet;
use target_spec::{Platform, TargetFeatures};

/// A type alias for `Summary` instances generated by `guppy`.
pub type Summary = SummaryWithMetadata<CargoOptionsSummary>;

impl<'g> CargoSet<'g> {
    /// Creates a build summary with the given options.
    #[doc(hidden)]
    pub fn to_summary(&self, opts: &CargoOptions<'_>) -> Summary {
        let metadata = CargoOptionsSummary::new(self.original_query.graph().package_graph, opts);
        let initials = self.original_query().clone().resolve_with_fn(|_, _| false);

        let target_features = self.target_features();
        let target_initials = initials.intersection(target_features);

        let host_features = self.host_features();
        let host_initials = initials.intersection(host_features);

        Summary {
            metadata: Some(metadata),
            target_initials: target_initials.to_package_map(),
            target_packages: target_features.to_package_map(),
            host_initials: host_initials.to_package_map(),
            host_packages: host_features.to_package_map(),
        }
    }
}

impl<'g> FeatureSet<'g> {
    /// Creates a `PackageMap` from this `FeatureSet`.
    fn to_package_map(&self) -> PackageMap {
        self.packages_with_features(DependencyDirection::Forward)
            .map(|feature_list| {
                (
                    feature_list.package().to_summary_id(),
                    feature_list
                        .features()
                        .iter()
                        .map(|feature| feature.to_string())
                        .collect(),
                )
            })
            .collect()
    }
}

impl<'g> PackageMetadata<'g> {
    /// Converts this metadata to a `SummaryId`.
    fn to_summary_id(&self) -> SummaryId {
        SummaryId {
            name: self.name().to_string(),
            version: self.version().clone(),
            source: self.source().to_summary_source(),
        }
    }
}

/// A summary of Cargo options used to build a `CargoSet`.
#[derive(Debug, Deserialize, Eq, PartialEq, Serialize)]
#[serde(rename_all = "kebab-case")]
#[non_exhaustive]
pub struct CargoOptionsSummary {
    /// The version of resolver used.
    pub version: CargoResolverVersion,

    /// Whether dev-dependencies are included.
    pub include_dev: bool,

    /// Whether procedural macros specified in initials are included in the target set.
    pub proc_macros_on_target: bool,

    /// The host platform.
    pub host_platform: Option<PlatformSummary>,

    /// The target platform.
    pub target_platform: Option<PlatformSummary>,

    /// The set of packages omitted from computations.
    pub omitted_packages: BTreeSet<SummaryId>,
}

impl CargoOptionsSummary {
    /// Creates a new `CargoOptionsSummary` from the given Cargo options.
    #[doc(hidden)]
    pub fn new(graph: &PackageGraph, opts: &CargoOptions<'_>) -> Self {
        let omitted_summary_ids = opts
            .imm_options
            .omitted_packages
            .iter()
            .map(|package_id| {
                let metadata = graph.metadata(package_id).expect("valid package ID");
                metadata.to_summary_id()
            })
            .collect();
        Self {
            version: opts.imm_options.version,
            include_dev: opts.imm_options.include_dev,
            proc_macros_on_target: opts.imm_options.proc_macros_on_target,
            host_platform: opts.imm_options.host_platform().map(PlatformSummary::new),
            target_platform: opts.imm_options.target_platform().map(PlatformSummary::new),
            omitted_packages: omitted_summary_ids,
        }
    }
}

impl<'g> PackageSource<'g> {
    /// Converts a `PackageSource` into a `SummarySource`.
    #[doc(hidden)]
    pub fn to_summary_source(&self) -> SummarySource {
        match self {
            PackageSource::Workspace(path) => SummarySource::workspace(path),
            PackageSource::Path(path) => SummarySource::path(path),
            PackageSource::External(source) => {
                if *source == PackageSource::CRATES_IO_REGISTRY {
                    SummarySource::crates_io()
                } else {
                    SummarySource::external(*source)
                }
            }
        }
    }
}

/// Summary of platform information.
#[derive(Debug, Deserialize, Eq, PartialEq, Serialize)]
#[serde(rename_all = "kebab-case")]
pub struct PlatformSummary {
    /// The platform triple.
    pub triple: String,

    /// The target features used. `None` means
    pub target_features: TargetFeaturesSummary,
}

impl PlatformSummary {
    /// Creates a new `PlatformSummary` instance.
    #[doc(hidden)]
    pub fn new(platform: &Platform<'_>) -> Self {
        Self {
            triple: platform.triple().to_string(),
            target_features: TargetFeaturesSummary::new(platform.target_features()),
        }
    }
}

/// Summary of target feature information.
#[derive(Debug, Deserialize, Eq, PartialEq, Serialize)]
#[serde(rename_all = "kebab-case")]
pub enum TargetFeaturesSummary {
    /// The target features are unknown.
    Unknown,
    /// Only match the specified features.
    Features(BTreeSet<String>),
    /// Match all features.
    All,
}

impl TargetFeaturesSummary {
    #[doc(hidden)]
    pub fn new(target_features: &TargetFeatures<'_>) -> Self {
        match target_features {
            TargetFeatures::Unknown => TargetFeaturesSummary::Unknown,
            TargetFeatures::Features(features) => TargetFeaturesSummary::Features(
                features.iter().map(|feature| feature.to_string()).collect(),
            ),
            TargetFeatures::All => TargetFeaturesSummary::All,
            other => panic!("Unknown target features: {:?}", other),
        }
    }
}
